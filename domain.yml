actions:
- utter_aprendizaje_no_supervizado_definicion
- utter_aprendizaje_por_refuerzo_definicion
- utter_aprendizaje_supervisado_definicion
- utter_cheer_up
- utter_did_that_help
- utter_goodbye
- utter_greet
- utter_happy
- utter_redes_neuronales_artificiales_definicion
- utter_redes_neuronales_artificiales_paradigmas
- utter_redes_neuronales_artificiales_problemas
- utter_sistemas_actuan_humano
- utter_sistemas_actuan_racionalmente
- utter_sistemas_expertos
- utter_sistemas_piensan_humano
- utter_sistemas_piensan_racionalmente
- utter_soy_asesor
- utter_regresion_polinomica
- utter_random_forest
- utter_bagging
- utter_forest_bagging
- utter_k_nearest_neighbors
- utter_svm
- utter_optimizacion_definicion
- uuter_optimizacion_caracteristicas
- utter_optimizacion_problemas
- utter_optimizacion_problema_viajante_comercio
- utter_optimizacion_problema_asignacion
- utter_optimizacion_problema_rutas
- utter_optimizacion_problema_flujo_maximo
- utter_optimizacion_problema_mochila
- utter_optimizacion_problema_inventario
- utter_funcion_objetivo
- utter_perceptron
- utter_adaline
- utter_mlp
- utter_machine_learning
- utter_default 

intents:
- redes_neuronales_artificiales_definicion
- aprendizaje_por_refuerzo_definicion
- sistemas_expertos
- greet
- redes_neuronales_artificiales_paradigmas
- goodbye
- affirm
- deny
- mood_great
- mood_unhappy
- bot_asesor
- aprendizaje_supervisado_definicion
- aprendizaje_no_supervizado_definicion
- redes_neuronales_artificiales_problemas
- sistemas_piensan_humano
- sistemas_actuan_humano
- sistemas_piensan_racionalmente
- sistemas_actuan_racionalmente
- regresion_polinomica
- random_forest
- bagging
- forest_bagging
- k_nearest_neighbor
- svm
- optimizacion_definicion
- optimizacion_caracteristicas
- optimizacion_problemas
- optimizacion_problema_viajante_comercio
- optimizacion_problema_asignacion
- optimizacion_problema_rutas
- optimizacion_problema_flujo_maximo
- optimizacion_problema_mochila
- optimizacion_problema_inventario
- funcion_objetivo
- perceptron
- adaline
- mlp
- machine_learning

responses:
  utter_aprendizaje_no_supervizado_definicion:
  - text: En el aprendizaje no supervisado, algunos datos x se da y la función de
      coste que se reduce al mínimo, que puede ser cualquier función de los datos
      x y la salida de la red, f.
  utter_aprendizaje_por_refuerzo_definicion:
  - text: El objetivo es descubrir una política para la selección de las acciones
      que minimiza una cierta medida de un costo a largo plazo
  utter_aprendizaje_supervisado_definicion:
  - text: Deseamos inferir el mapeo derivado de los datos; la función de coste está
      relacionado con la falta de coincidencia entre nuestro mapeo y los datos, y
      contiene implícitamente el conocimiento previo sobre el dominio del problema
  utter_cheer_up:
  - image: https://i.imgur.com/nGF1K8f.jpg
    text: 'Esto te puede ayudar:'
  utter_did_that_help:
  - text: ¿Eso te ayudo?
  utter_goodbye:
  - text: Adiós.
  utter_greet:
  - text: Hey! ¿Como estas?
  utter_happy:
  - text: Genial, sigue asi!
  utter_redes_neuronales_artificiales_definicion:
  - text: Son un modelo computacional vagamente inspirado en el comportamiento observado
      en su homólogo biológico
  utter_redes_neuronales_artificiales_paradigmas:
  - buttons:
    - payload: /aprendizaje_supervisado_definicion
      title: Supervisado
    - payload: /aprendizaje_no_supervizado_definicion
      title: No supervisado
    - payload: /aprendizaje_por_refuerzo_definicion
      title: Por refuerzo
    text: Hay tres grandes paradigmas de aprendizaje, cada uno correspondiente a una
      tarea de aprendizaje abstracto en particular. Estos son el aprendizaje supervisado
      ,el aprendizaje no supervisado y el aprendizaje por refuerzo.
  utter_redes_neuronales_artificiales_problemas:
  - text: Las redes neuronales se han utilizado para resolver una amplia variedad
      de tareas, como la visión por computador y el reconocimiento de voz
  utter_sistemas_actuan_humano:
  - text: Se trata de computadoras que realizan tareas de forma similar a como lo
      hacen las personas. Es el caso de los robots.
  utter_sistemas_actuan_racionalmente:
  - text: Idealmente, son aquellos que tratan de imitar de manera racional el comportamiento
      humano, como los agentes inteligentes.
  utter_sistemas_expertos:
  - text: Es un sistema que emplea conocimiento humano capturado en un ordenador para
      resolver problemas que normalmente resolverían humanos expertos. Los sistemas
      bien diseñados imitan el proceso de razonamiento que los expertos utilizan para
      resolver problemas específicos.
  utter_sistemas_piensan_humano:
  - text: Automatizan actividades como la toma de decisiones, la resolución de problemas
      y el aprendizaje. Un ejemplo son las redes neuronales artificiales.
  utter_sistemas_piensan_racionalmente:
  - text: Sistemas que intentan emular el pensamiento lógico racional de los humanos,
      es decir, se investiga cómo lograr que las máquinas puedan percibir, razonar
      y actuar en consecuencia. Los sistemas expertos se engloban en este grupo.
  utter_soy_asesor:
  - text: Soy un asesor que te apoyará a guiarte para obtener las respuestas de tus
      dudas.
  utter_regresion_polinomica:
  - text: La regresión lineal múltiple permite generar un modelo lineal en el que el valor de la
          variable dependiente o respuesta (Y) se determina a partir de un conjunto de variables
          independientes llamadas predictores (X1, X2, X3…). Es una extensión de la regresión lineal
          simple, por lo que es fundamental comprender esta última. Los modelos de regresión múltiple
          pueden emplearse para predecir el valor de la variable dependiente o para evaluar la
          influencia que tienen los predictores sobre ella.
  utter_bagging:
  - text: La agregación de Bootstrap, también llamada bagging (de Bootstrap aggregating), es un meta-algoritmo 
          de conjunto de aprendizaje automático diseñado para mejorar la estabilidad y precisión de los 
          algoritmos de aprendizaje automático utilizados en la clasificación estadística y la regresión. 
          También reduce la variación y ayuda a evitar el sobre entrenamiento.
  utter_random_forest:
  - text: El método de random forest es una modificación del proceso de bagging que consigue mejores
          resultados gracias a que decorrelaciona los árboles generados en el proceso.
          Supóngase un set de datos en el que hay un predictor muy influyente junto con otros moderadamente
          influyentes. En este escenario, todos o casi todos los árboles creados en el proceso de bagging 
          estarán dominados por el mismo predictor y serán muy parecidos entre ellos.
          Como consecuencia de la alta correlación entre los árboles, el proceso de bagging apenas conseguirá
          disminuir la varianza y, por lo tanto, tampoco mejorar el modelo.
  utter_forest_bagging:
  - text: Los métodos de random forest y bagging siguen el mismo algoritmo con la única diferencia de que,
          en random forest, antes de cada división se seleccionan aleatoriamente [Math Processing Error] predictores.
  utter_k_nearest_neighbors:
  - text: K-Nearest Neighbor es uno de los algoritmos de machine learning más simples. Se fundamenta en la idea de
          identificar observaciones en el conjunto de entrenamiento que se asemejen a la observación de test
          (observaciones vecinas) y asignarle como valor predicho la clase predominante entre dichas observaciones.
  utter_svm:
  - text: Es un clasificador basado en un hiperplano es más robusto y tiene mayor capacidad predictiva al aplicarlo a
          nuevas observaciones (menos problemas de overfitting). Esto es exactamente lo que consiguen los clasificadores
          de vector soporte, también conocidos como soft margin classifiers o Support Vector Classifiers. Para lograrlo,
          en lugar de buscar el margen de clasificación más ancho posible que consigue que las observaciones estén en el
          lado correcto del margen; se permite que ciertas observaciones estén en el lado incorrecto del margen o incluso del hiperplano.

  utter_optimizacion_definicion:
  - text: Los problemas de optimización aparecen en multitud de ámbitos, desde la elección del camino más corto para 
          ir al trabajo hasta el diseño óptimo de rutas de reparto de mercancías de una gran multinacional. 
          Un problema de optimización viene dado por un par (F, c) donde F es un dominio de puntos factibles 
          y c una función coste. El problema consiste en encontrar un punto factible x ∈ F tal que ∀y ∈ F 
          verifique, c(x) ≤ c(y). Cada punto x verificando las condiciones anteriormente descritas se denomina 
          óptimo global del problema.
  utter_optimizacion_caracteristicas:
  - text: Proceso algorítmico inicial muy rápido.
          Elección de la mejor alternativa entre todas las alternativas posibles.
  utter_optimizacion_problema_viajante_comercio:
  - text: 'El problema del viajante de comercio, TSP (Travelling Salesman Problem): es uno de los problemas 
          clásicos de optimización combinatoria. Recibió este nombre porque puede describirse en términos de 
          un agente de ventas que debe visitar cierta cantidad de ciudades en un solo viaje. Si comienza desde 
          su ciudad de residencia, el agente debe determinar qué ruta debe seguir para visitar cada ciudad 
          exactamente una vez antes de regresar a su casa de manera que se minimice la longitud total del viaje.'
  utter_optimizacion_problema_asignacion:
  - text: 'Problemas asignación: Caso particular del problema de transporte de bienes desde unos orígenes a 
          unos destinos donde los asignados son recursos destinados a la realización de tareas, los asignados 
          pueden ser personas, máquinas, vehículos, plantas o periodos de tiempo. En estos problemas la oferta 
          en cada origen es de valor 1 y la demanda en cada destino es también de valor 1.'
  utter_optimizacion_problema_rutas:
  - text: 'Problemas de rutas, Vehicle Routing Problems (VRP). Se trata de diseñar las rutas de una flota 
          de transporte para dar servicio a unos clientes.'
  utter_optimizacion_problema_flujo_maximo:
  - text: 'Problemas de flujo máximo: Capacidad en redes. En una red en la que los arcos tienen limitada su 
          capacidad, el problema del flujo máximo consiste en maximizar la cantidad de flujo que se puede 
          pasar entre dos nodos prefijados de la red.'
  utter_optimizacion_problema_mochila:
  - text: 'El problema de la mochila. Supongamos que un excursionista debe decidir qué cosas incluir en su 
          mochila. El problema consiste en decidir qué objetos incluir, teniendo en cuenta que la mochila 
          soporta un peso máximo, de forma que maximice la utilidad que le proporcionarán los objetos elegidos.'
  utter_optimizacion_problema_inventario:
  - text: 'Problemas de inventario. Se trata de optimizar la gerencia sobre cuánto producir, cuánto demorar y 
          cuánto almacenar en cada período de un horizonte de planificación dado.'
  utter_optimizacion_problemas:
  - buttons:
    - payload: /optimizacion_problema_viajante_comercio
      title: Viajante de comercio
    - payload: /optimizacion_problema_asignacion
      title: Asignación
    - payload: /optimizacion_problema_rutas
      title: Rutas
    - payload: /optimizacion_problema_flujo_maximo
      title: Flujo máximo
    - payload: /optimizacion_problema_mochila
      title: Mochila
    - payload: /optimizacion_problema_inventario
      title: Inventario
    text: Viajante de comercio, asignación, de rutas, de flujo máximo, de la mochila y de inventario.
  utter_funcion_objetivo:
  - text: 'Es la medida cuantitativa del rendimiento del sistema a optimizar (maximizar o minimizar). Algunos 
          ejemplos de las funciones objetivo son: la minimización de los costes de un sistema de producción 
          agrícola, la maximización de los beneficios netos de la venta de ciertos productos, la minimización 
          de los materiales utilizados en la fabricación de un producto, etc.'
  utter_perceptron:
  - text: 'El perceptrón simple es un tipo de red neuronal artificial desarrollado por Frank Rosenblatt en 1959.
          La razón de su auge en los años 60’s es que tiene capacidad de aprendizaje y reconocimiento de patrones linealmente separables.
          El perceptrón puede ser considerado como una neurona artificia, unidad de cálculo que intenta modelar el comportamiento de una neurona natural,
          como las que constituyen el cerebro humano. Es un algoritmo capaz de generar un criterio para hacer la selección de un grupo,
          entre un grupo de elementos más grandes.'
  utter_adaline:
  - text: 'La Red Adaline fue desarrollada en el 1960 por Bernard Widrow y su estudiante Marcian Hoff de la universidad de Stanford.
          ADALINE proviene de Adaptive Lineal Element (Elemento Lineal Adaptativo), pero antes de que se le diera este nombre esta red sufrió
          un cambio ya  que primeramente se llamaba Adaptive Lineal Neuron (Neurona Linear Adaptiva), dicho cambio se dio por que la Red Adaline
          es un dispositivo que consta de un único elemento de procesamiento, como tal no es técnicamente considerada una red neuronal.
          Adaline fue desarrollada para el reconocimiento de patrones binarios, por ejemplo predecir el siguiente bit en una línea telefónica.'
  utter_mlp:
  - text: 'Este tipo de red artificial nació de la unión de varios perceptrones simples, estas redes neuronales multicapa se pueden clasificar
          de manera que que se conectan sus capas, este tipo de neuronas dio paso a la resolución de problemas mas complejos como los no lineales.
          Esta idea fue propuesta por los cientificos Rumelhart, Hinton y Williams en el año 1986 cuya hipotesis era la de retro propagar los errores
          medidos en las señales de salida de la red neuronal artificial hacia las neuronas que se encuentran en la capa oculta.'
  utter_machine_learning:
  - text: 'Es una derivación de inteligencia artificial que crea sistemas que aprenden de manera automatizada, es decir, identificar patrones complejos
          en millones de datos, predecir comportamientos todo mediante un algoritmo y que además de todo son capaces de mejorarse de manera independiente con el tiempo.'
  utter_default:
  - text: 'Lo siento no entiendo :('
session_config:
  carry_over_slots_to_new_session: true
  session_expiration_time: 60
